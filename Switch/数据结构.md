数组

是一种线性表数据结构，用一组连续的内存空间来存储一组具有相同类型的数据。

特性是支持随机访问，按下标查找为O(1)；但插入和删除比较低效，平均复杂度为O(n)。



链表

链表不需要连续的内存空间，它通过“指针”，将一组零散的内存块串联起来使用

代码对内存的使用非常苛刻，那数组更合适。因数链表中的每个指针需要额外的存储空间。而且对链表进行频繁的插入、删除操作，还会导致频繁的内存申请和释放，容易造成内存碎片

```c
/* 节点插入*/
newnode -> next = p->next;
p->next = newnode;

/* 节点删除*/
p->next = p->next->next;


```



栈

先进者后出

```c
#define STACK_CAPACITY 100

struct stack{
    int* arr;
    int top;
    int capacity;
};

/* 栈的初始化 */
int stack_init(struct stack*v){
    v->capacity = STACK_CAPACITY;
    v->arr = (int*)malloc(v->capacity * sizeof(int));
    if(v->arr == NULL){
        perror("malloc v->capacity failed");
        return -1;
    }
    v->top = 0;
    return 0;
}

/* 入栈操作 */
int stack_push(struct stack*stk, int value){
    if(stk == NULL){
        printf("stack is NULL\r\n");
        return -1;
    }

    if(stk->top == stk->capacity){
        printf("stack_push failed\r\n");
        return -1;
    }
    stk->arr[stk->top] = value;
    stk->top++;
    return 0;
}

/* 出栈操作*/
int stack_pop(struct stack*stk){
    if(stk == NULL || stk->top == 0){
        printf("stack_pop failed\r\n");
        return -1;
    }
    stk->top--;
    return 0;
}

/* 获取栈的顶部元素 */
int stack_peak(struct stack*stk){
    if(stk == NULL ||stk->top == 0){
        return -1;
    }
    return stk->arr[stk->top-1];

}

/* 栈的销毁 */
void stack_destory(struct stack*stk){
    if(stk == NULL){
        return;
    }
    free(stk->arr);
    stk->capacity = 0;
    stk->top = 0;
    free(stk);
    printf("stack_destory success\r\n");
}

int main(void){
    stack* stk = (struct stack*)malloc(sizeof(stack));
    if(stk == NULL){
        perror("malloc stk failed");
        return -1;
    }
    stack_init(stk);

    return 0;
}

```

队列

先进先出

```c
struct node{
    int val;
    struct node* next;
};

struct queue{
    struct node* frist;
    struct node* last;
};

/* 队列初始化 */
int queue_init(struct queue* q){
    if(q == NULL){
        printf("queue is null\r\n");
        return -1;
    }

    q->frist = NULL;
    q->last = NULL;
    return 0;
}

/* 入队操作 */
int queue_enqueue(struct queue*q, int val){
    if(q == NULL){
        printf("queue is null\r\n");
        return -1;
    }
    struct node* new_node = (struct node*)malloc(sizeof(struct node));
    if(new_node == NULL){
        perror("malloc error");
        return -1;
    }
    new_node->val = val;
    if(q->frist == NULL){
        q->frist = new_node;
        q->last = new_node;
    }
    else{
        q->last->next = new_node;
        q->last = q->last->next;
    }
    return 0;
}

/* 出队操作 */
int queue_dequeue(strcut queue*q){
    if(q == NULL && q->frist == NULL){
        printf("queue is empty\r\n");
        return -1;
    }
    struct node* temp = q->frist;
    q->frist = q->frist->next;
    if(q->frist == NULL){
        q->last = NULL;
    }
    free(temp);
    temp = NULL;
    return 0;

}

/* 获取队头的操作 */
int queue_peak(struct queue*q){
    if(q == NULL || q->front == NULL){
        printf("queue is empty\r\n");
        return -1;
    }
    return q->frist->val;
}

/* 队列销毁 */
int queue_destroy(struct queue*q){
    if(q == NULL){
        printf("queue is null\r\n");
        return -1;
    }
    struct node*temp = q->frist;
    while(temp!= NULL){
        struct node*next = temp->next;
        free(temp);
        temp = next;
    }
    q->frist = NULL;
    q->last = NULL;
    return 0;
}
```



递归

需要满足3个条件：

（1） 一个问题的解可以分解为几个子问题的解

（2）这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样

（3）存在递归终止条件



二分法

用于有序数组中，二分法查找的效果比较高效，时间复杂度为O(logn)。但太少的数据不适合二分法，因为查找速度差不多；数据量很大也不适合二分法，数组是连续的内存空间，太大的数据量不适合使用数组

```c
/*
代码写法：
1.循环退出条件：low<=high
2.取值：mid = low + (high - low) >> 1
3.low 和 high 值的更新：low = mid -1 ; high = mid + 1
*/
int bsearch(int*arr ,int n ,int value ){
    if(arr == NULL || n <= 0){
        return -1;
    }
    int low = 0;
    int high = n - 1;
    int mid = 0;
    while(low <= high){
        mid = low + ((high - low)>>1);
        if(arr[mid] == value){
            return mid;
        }
        else if(arr[mid] < value){
            low = mid + 1;
        }
        else{
            high = mid -1;
        }
    }
    return -1;
}

/*
二分法的四种变形：
（1）查找第一个值等于给定元素的值
（2）查找最后一个值等于给定元素的值
（3）查找第一个值大于等于给定元素的值
（4）查找最后一个值大于等于给定元素的值
*/

/*（1）查找第一个值等于给定元素的值    */
int bsearch(int*arr ,int n ,int value){
    if(arr == NULL || n <= 0){
        return -1;
    }
    int low = 0;
    int high = n - 1;
    int mid = 0;
    while(low <= high){
        mid = low + ((high - low)>>1);
        if(arr[mid] >= value){
            high = mid -1;
        }
        else{
            low = mid + 1;
        }
    }
    
    if(low < n &&arr[low] == value){
        return low;
    }
    else{
        return -1;
    }
}



/*（2）查找最后一个值等于给定元素的值   */
int bsearch(int*arr ,int n ,int value){
    if(arr == NULL || n <= 0){
        return -1;
    }
    int low = 0;
    int high = n - 1;
    int mid = 0;
    while(low <= high){
        mid = low + ((high - low)>>1);
        if(arr[mid] <= value){
            low = mid + 1;
        }
        else{
            high = mid - 1;
        }
    }
    
    if(high >= 0  && arr[high] == value){
        return high;
    }
    else{
        return -1;
    }
}


/*（3）查找第一个值大于等于给定元素的值  */
int bsearch(int*arr ,int n ,int value){
    if(arr == NULL || n <= 0){
        return -1;
    }
    int low = 0;
    int high = n - 1;
    int mid = 0;
    while(low <= high){
        mid = low + ((high - low)>>1);
        if(arr[mid] >= value){
            high = mid -1;
        }
        else{
            low = mid + 1;
        }
    }
    
    if(low < n){
        return low;
    }
    else{
        return -1;
    }
}


/*（4）查找最后一个值大于等于给定元素的值 */
int bsearch(int*arr ,int n ,int value){
    if(arr == NULL || n <= 0){
        return -1;
    }
    int low = 0;
    int high = n - 1;
    int mid = 0;
    while(low <= high){
        mid = low + ((high - low)>>1);
        if(arr[mid] <= value){
            low = mid + 1;
        }
        else{
            high = mid - 1;
        }
    }
    
    if(high >= 0){
        return high;
    }
    else{
        return -1;
    }
}


```

