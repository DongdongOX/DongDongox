数组

是一种线性表数据结构，用一组连续的内存空间来存储一组具有相同类型的数据。

特性是支持随机访问，按下标查找为O(1)；但插入和删除比较低效，平均复杂度为O(n)。



链表

链表不需要连续的内存空间，它通过“指针”，将一组零散的内存块串联起来使用

代码对内存的使用非常苛刻，那数组更合适。因数链表中的每个指针需要额外的存储空间。而且对链表进行频繁的插入、删除操作，还会导致频繁的内存申请和释放，容易造成内存碎片

```c
/* 节点插入*/
newnode -> next = p->next;
p->next = newnode;

/* 节点删除*/
p->next = p->next->next;


```



栈

先进者后出

```c
#define STACK_CAPACITY 100

struct stack{
    int* arr;
    int top;
    int capacity;
};

/* 栈的初始化 */
int stack_init(struct stack*v){
    v->capacity = STACK_CAPACITY;
    v->arr = (int*)malloc(v->capacity * sizeof(int));
    if(v->arr == NULL){
        perror("malloc v->capacity failed");
        return -1;
    }
    v->top = 0;
    return 0;
}

/* 入栈操作 */
int stack_push(struct stack*stk, int value){
    if(stk == NULL){
        printf("stack is NULL\r\n");
        return -1;
    }

    if(stk->top == stk->capacity){
        printf("stack_push failed\r\n");
        return -1;
    }
    stk->arr[stk->top] = value;
    stk->top++;
    return 0;
}

/* 出栈操作*/
int stack_pop(struct stack*stk){
    if(stk == NULL || stk->top == 0){
        printf("stack_pop failed\r\n");
        return -1;
    }
    stk->top--;
    return 0;
}

/* 获取栈的顶部元素 */
int stack_peak(struct stack*stk){
    if(stk == NULL ||stk->top == 0){
        return -1;
    }
    return stk->arr[stk->top-1];

}

/* 栈的销毁 */
void stack_destory(struct stack*stk){
    if(stk == NULL){
        return;
    }
    free(stk->arr);
    stk->capacity = 0;
    stk->top = 0;
    free(stk);
    printf("stack_destory success\r\n");
}

int main(void){
    stack* stk = (struct stack*)malloc(sizeof(stack));
    if(stk == NULL){
        perror("malloc stk failed");
        return -1;
    }
    stack_init(stk);

    return 0;
}

```

队列

先进先出

```c
struct node{
    int val;
    struct node* next;
};

struct queue{
    struct node* frist;
    struct node* last;
};

/* 队列初始化 */
int queue_init(struct queue* q){
    if(q == NULL){
        printf("queue is null\r\n");
        return -1;
    }

    q->frist = NULL;
    q->last = NULL;
    return 0;
}

/* 入队操作 */
int queue_enqueue(struct queue*q, int val){
    if(q == NULL){
        printf("queue is null\r\n");
        return -1;
    }
    struct node* new_node = (struct node*)malloc(sizeof(struct node));
    if(new_node == NULL){
        perror("malloc error");
        return -1;
    }
    new_node->val = val;
    if(q->frist == NULL){
        q->frist = new_node;
        q->last = new_node;
    }
    else{
        q->last->next = new_node;
        q->last = q->last->next;
    }
    return 0;
}

/* 出队操作 */
int queue_dequeue(strcut queue*q){
    if(q == NULL && q->frist == NULL){
        printf("queue is empty\r\n");
        return -1;
    }
    struct node* temp = q->frist;
    q->frist = q->frist->next;
    if(q->frist == NULL){
        q->last = NULL;
    }
    free(temp);
    temp = NULL;
    return 0;

}

/* 获取队头的操作 */
int queue_peak(struct queue*q){
    if(q == NULL || q->front == NULL){
        printf("queue is empty\r\n");
        return -1;
    }
    return q->frist->val;
}

/* 队列销毁 */
int queue_destroy(struct queue*q){
    if(q == NULL){
        printf("queue is null\r\n");
        return -1;
    }
    struct node*temp = q->frist;
    while(temp!= NULL){
        struct node*next = temp->next;
        free(temp);
        temp = next;
    }
    q->frist = NULL;
    q->last = NULL;
    return 0;
}
```



递归

需要满足3个条件：

（1） 一个问题的解可以分解为几个子问题的解

（2）这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样

（3）存在递归终止条件



二分法

用于有序数组中，二分法查找的效果比较高效，时间复杂度为O(logn)。但太少的数据不适合二分法，因为查找速度差不多；数据量很大也不适合二分法，数组是连续的内存空间，太大的数据量不适合使用数组

```c
/*
代码写法：
1.循环退出条件：low<=high
2.取值：mid = low + (high - low) >> 1
3.low 和 high 值的更新：low = mid -1 ; high = mid + 1
*/
int bsearch(int*arr ,int n ,int value ){
    if(arr == NULL || n <= 0){
        return -1;
    }
    int low = 0;
    int high = n - 1;
    int mid = 0;
    while(low <= high){
        mid = low + ((high - low)>>1);
        if(arr[mid] == value){
            return mid;
        }
        else if(arr[mid] < value){
            low = mid + 1;
        }
        else{
            high = mid -1;
        }
    }
    return -1;
}

/*
二分法的四种变形：
（1）查找第一个值等于给定元素的值
（2）查找最后一个值等于给定元素的值
（3）查找第一个值大于等于给定元素的值
（4）查找最后一个值大于等于给定元素的值
*/

/*（1）查找第一个值等于给定元素的值    */
int bsearch(int*arr ,int n ,int value){
    if(arr == NULL || n <= 0){
        return -1;
    }
    int low = 0;
    int high = n - 1;
    int mid = 0;
    while(low <= high){
        mid = low + ((high - low)>>1);
        if(arr[mid] >= value){
            high = mid -1;
        }
        else{
            low = mid + 1;
        }
    }
    
    if(low < n &&arr[low] == value){
        return low;
    }
    else{
        return -1;
    }
}



/*（2）查找最后一个值等于给定元素的值   */
int bsearch(int*arr ,int n ,int value){
    if(arr == NULL || n <= 0){
        return -1;
    }
    int low = 0;
    int high = n - 1;
    int mid = 0;
    while(low <= high){
        mid = low + ((high - low)>>1);
        if(arr[mid] <= value){
            low = mid + 1;
        }
        else{
            high = mid - 1;
        }
    }
    
    if(high >= 0  && arr[high] == value){
        return high;
    }
    else{
        return -1;
    }
}


/*（3）查找第一个值大于等于给定元素的值  */
int bsearch(int*arr ,int n ,int value){
    if(arr == NULL || n <= 0){
        return -1;
    }
    int low = 0;
    int high = n - 1;
    int mid = 0;
    while(low <= high){
        mid = low + ((high - low)>>1);
        if(arr[mid] >= value){
            high = mid -1;
        }
        else{
            low = mid + 1;
        }
    }
    
    if(low < n){
        return low;
    }
    else{
        return -1;
    }
}


/*（4）查找最后一个值大于等于给定元素的值 */
int bsearch(int*arr ,int n ,int value){
    if(arr == NULL || n <= 0){
        return -1;
    }
    int low = 0;
    int high = n - 1;
    int mid = 0;
    while(low <= high){
        mid = low + ((high - low)>>1);
        if(arr[mid] <= value){
            low = mid + 1;
        }
        else{
            high = mid - 1;
        }
    }
    
    if(high >= 0){
        return high;
    }
    else{
        return -1;
    }
}


```

散列表

散列表用的就是数组支持按照下标随机访问的时候，时间复杂度是 O(1) 的特性。我们通过散列函数把元素的键值映射为下标，然后将数据存储在数组中对应下标的位置

```
 
int hash(String key) {
  // 获取后两位字符
  string lastTwoChars = key.substr(length-2, length);
  // 将后两位字符转换为整数
  int hashValue = convert lastTwoChas to int-type;
  return hashValue;
}
```

**散列函数设计的基本要求：**

1. 散列函数计算得到的散列值是一个非负整数；
2. 如果 key1 = key2，那 hash(key1) == hash(key2)；
3. 如果 key1 ≠ key2，那 hash(key1) ≠ hash(key2)。

第三点要求看起来合情合理，但是在真实的情况下，要想找到一个不同的 key 对应的散列值都不一样的散列函数，几乎是不可能的。即便像业界著名的**MD5、SHA、CRC**等哈希算法，也无法完全避免这种散列冲突。而且，因为数组的存储空间有限，也会加大散列冲突的概率。

**散列冲突**

1、开放寻址法

开放寻址法的核心思想是，如果出现了散列冲突，我们就重新探测一个空闲位置，将其插入。那如何重新探测新的位置呢？我先讲一个比较简单的探测方法，线性探测（Linear Probing）。

当我们往散列表中插入数据时，如果某个数据经过散列函数散列之后，存储位置已经被占用了，我们就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到为止。
在散列表中查找元素的过程有点儿类似插入过程。我们通过散列函数求出要查找元素的键值对应的散列值，然后比较数组中下标为散列值的元素和要查找的元素。如果相等，则说明就是我们要找的元素；否则就顺序往后依次查找。如果遍历到数组中的空闲位置，还没有找到，就说明要查找的元素并没有在散列表中。

我们可以将删除的元素，特殊标记为 deleted。当线性探测查找的时候，遇到标记为 deleted 的空间，并不是停下来，而是继续往下探测。

线性探测法其实存在很大问题。当散列表中插入的数据越来越多时，散列冲突发生的可能性就会越来越大，空闲位置会越来越少，线性探测的时间就会越来越久。极端情况下，我们可能需要探测整个散列表，所以最坏情况下的时间复杂度为 O(n)。同理，在删除和查找时，也有可能会线性探测整张散列表，才能找到要查找或者删除的数据。

对于开放寻址冲突解决方法，除了线性探测方法之外，还有另外两种比较经典的探测方法，二次探测（Quadratic probing）和双重散列（Double hashing）。

所谓二次探测，跟线性探测很像，线性探测每次探测的步长是 1，那它探测的下标序列就是 hash(key)+0，hash(key)+1，hash(key)+2……而二次探测探测的步长就变成了原来的“二次方”，也就是说，它探测的下标序列就是 hash(key)+0，hash(key)+12，hash(key)+22……

所谓双重散列，意思就是不仅要使用一个散列函数。我们使用一组散列函数 hash1(key)，hash2(key)，hash3(key)……我们先用第一个散列函数，如果计算得到的存储位置已经被占用，再用第二个散列函数，依次类推，直到找到空闲的存储位置。

不管采用哪种探测方法，当散列表中空闲位置不多的时候，散列冲突的概率就会大大提高。为了尽可能保证散列表的操作效率，一般情况下，我们会尽可能保证散列表中有一定比例的空闲槽位。我们用装载因子（load factor）来表示空位的多少。

装载因子的计算公式是：

               散列表的装载因子 = 填入表中的元素个数 / 散列表的长度
**2、链表法**

链表法是一种更加常用的散列冲突解决办法，相比开放寻址法，它要简单很多。在散列表中，每个“桶（bucket）”或者“槽（slot）”会对应一条链表，所有散列值相同的元素我们都放到相同槽位对应的链表中。

![img](https://i-blog.csdnimg.cn/blog_migrate/5ee0e9524eeb3862dd19809a28d4d16c.jpeg)

当插入的时候，我们只需要通过散列函数计算出对应的散列槽位，将其插入到对应链表中即可，所以插入的时间复杂度是 O(1)。当查找、删除一个元素时，我们同样通过散列函数计算出对应的槽，然后遍历链表查找或者删除。那查找或删除操作的时间复杂度是多少呢？

实际上，这两个操作的时间复杂度跟链表的长度 k 成正比，也就是 O(k)。对于散列比较均匀的散列函数来说，理论上讲，k=n/m，其中 n 表示散列中数据的个数，m 表示散列表中“槽”的个数。
